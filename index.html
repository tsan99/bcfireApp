<!DOCTYPE html>
<html>
<head>
  <title>BC Wildfire Map - TS</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet CSS & JS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Proj4 for projection conversion -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>

  <style>
    body { font-family: Arial, sans-serif; padding: 10px; }
    #map { height: 500px; margin-top: 15px; }
    .controls { margin-bottom: 10px; }
    label, input { display: block; margin: 4px 0; }
  </style>
</head>
<body>

<h2>üî• BC Wildfire Map</h2>

<div class="controls">
  <button onclick="getLocation()">üìç Use My Location</button><br>

  <label>Or manually enter coordinates:</label>
  Latitude: <input type="number" id="lat" step="any" placeholder="49.xxx">
  Longitude: <input type="number" id="lon" step="any" placeholder="-123.xxx">
  <button onclick="manualCheck()">Check Fires Near Me</button>

  <label>Search Radius: <span id="radiusLabel">500</span> km</label>
  <input type="range" id="radiusSlider" min="100" max="1000" step="100" value="500" oninput="updateRadiusLabel()">

  <label><input type="checkbox" id="autoRefresh"> Auto-refresh every 60s</label>
</div>

<p id="status">Status: Waiting‚Ä¶</p>
<div id="map"></div>

<script>
  const pointAPI = 'https://delivery.maps.gov.bc.ca/arcgis/rest/services/whse/bcgw_pub_whse_land_and_natural_resource/MapServer/20';
  proj4.defs("EPSG:102190", "+proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000 +y_0=0 +datum=NAD83 +units=m +no_defs");

  let map, layerGroup, userMarker;
  let refreshTimer, userLat, userLon;

  initMap();

  function initMap(lat = 53.7, lon = -127.6) {
    map = L.map('map').setView([lat, lon], 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OSM contributors'
    }).addTo(map);
    layerGroup = L.layerGroup().addTo(map);
  }

  function getLocation() {
    navigator.geolocation?.getCurrentPosition(
      pos => checkLoc(pos.coords.latitude, pos.coords.longitude),
      showError
    );
  }

  function manualCheck() {
    const lat = parseFloat(document.getElementById('lat').value);
    const lon = parseFloat(document.getElementById('lon').value);
    if (!isNaN(lat) && !isNaN(lon)) {
      checkLoc(lat, lon);
    } else {
      alert("Please enter valid coordinates.");
    }
  }

  function updateRadiusLabel() {
    const radius = document.getElementById("radiusSlider").value;
    document.getElementById("radiusLabel").textContent = radius;
  }

  function getRadiusMeters() {
    return parseInt(document.getElementById("radiusSlider").value, 10) * 1000;
  }

  function checkLoc(lat, lon) {
    userLat = lat;
    userLon = lon;
    map.setView([lat, lon], 7);
    layerGroup.clearLayers();
    if (userMarker) map.removeLayer(userMarker);
    userMarker = L.marker([lat, lon]).addTo(layerGroup).bindPopup("üìç You").openPopup();
    document.getElementById("status").innerText = "Querying nearby fires‚Ä¶";
    queryFires();
    if (document.getElementById("autoRefresh").checked) {
      clearInterval(refreshTimer);
      refreshTimer = setInterval(() => queryFires(), 60000);
    } else {
      clearInterval(refreshTimer);
    }
  }

  function queryFires() {
    const radiusMeters = getRadiusMeters();
    const radiusKm = radiusMeters / 1000;

    const params = new URLSearchParams({
      where: "1=1",
      geometry: `${userLon},${userLat}`,
      geometryType: "esriGeometryPoint",
      spatialRel: "esriSpatialRelIntersects",
      distance: radiusMeters,
      inSR: "4326",
      outFields: "*",
      f: "json"
    });

    fetch(pointAPI + "/query?" + params)
      .then(res => res.json())
      .then(resp => {
        if (resp.error) {
          document.getElementById("status").innerText = "API error: " + resp.error.message;
          return;
        }

        const fires = resp.features || [];
        if (fires.length === 0) {
          document.getElementById("status").innerText = `‚úÖ No nearby fires within ${radiusKm} km.`;
          return;
        }

        document.getElementById("status").innerText = `‚ö†Ô∏è ${fires.length} fire(s) detected within ${radiusKm} km`;

        const bounds = [];

        fires.forEach(f => {
          const g = f.geometry;
          const props = f.attributes || {};

          let lat, lon;

          if (g.x != null && g.y != null) {
            [lon, lat] = proj4("EPSG:102190", "EPSG:4326", [g.x, g.y]);
          } else if (g.rings && Array.isArray(g.rings)) {
            const ring = g.rings[0];
            const total = ring.reduce((sum, [x, y]) => {
              sum.x += x;
              sum.y += y;
              return sum;
            }, { x: 0, y: 0 });
            const count = ring.length;
            const avgX = total.x / count;
            const avgY = total.y / count;
            [lon, lat] = proj4("EPSG:102190", "EPSG:4326", [avgX, avgY]);
          } else {
            console.warn("Skipping fire with unrecognized geometry:", g);
            return;
          }

          bounds.push([lat, lon]);

          L.circleMarker([lat, lon], {
            radius: 10,
            fillColor: "red",
            color: "#800000",
            weight: 2,
            opacity: 1,
            fillOpacity: 0.7
          }).addTo(layerGroup).bindPopup(`
            üî• Fire ID: ${props.FIRE_NUMBER || 'N/A'}<br>
            Distance: ${getDist(lat, lon).toFixed(1)} km
          `);
        });

        if (bounds.length > 0) {
          map.fitBounds(bounds, { padding: [20, 20] });
        }
      })
      .catch(err => {
        console.error("API fetch error:", err);
        document.getElementById("status").innerText = "‚ùå Failed to load fire data.";
      });
  }

  function getDist(lat2, lon2) {
    const toRad = deg => deg * Math.PI / 180;
    const R = 6371;
    const dLat = toRad(lat2 - userLat);
    const dLon = toRad(lon2 - userLon);
    const a = Math.sin(dLat / 2) ** 2 +
              Math.cos(toRad(userLat)) * Math.cos(toRad(lat2)) *
              Math.sin(dLon / 2) ** 2;
    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  }

  function showError(e) {
    const msg = {
      1: "Permission denied",
      2: "Position unavailable",
      3: "Timeout"
    }[e.code] || "Unknown error";
    document.getElementById("status").innerText = `Geolocation error: ${msg}`;
  }

  updateRadiusLabel(); // Initialize radius label on load
</script>

</body>
</html>
