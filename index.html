<!DOCTYPE html>
<html>
<head>
  <title>BC Wildfire Map (Debug & Safe Filter)</title>
  <meta charset="utf‚Äë8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    #map { height: 500px; margin-top: 15px; }
    body { font-family: Arial, sans-serif; padding: 10px; }
    .controls { margin-bottom: 10px; }
    label, input, select { display: block; margin: 4px 0; }
  </style>
</head>
<body>

<h2>üî• BC Wildfire Map (Debug + Field Check)</h2>

<div class="controls">
  <button onclick="getLocation()">üìç Use My Location</button><br>
  <label>Or manually:</label>
  Lat: <input type="number" id="lat" step="any" placeholder="49.xxx">
  Lon: <input type="number" id="lon" step="any" placeholder="-123.xxx">
  <button onclick="manualCheck()">Check Coordinates</button>

  <label>Status Filter:</label>
  <select id="statusFilter">
    <option value="">All</option>
    <option value="OUT">OUT</option>
    <option value="ACTIVE">ACTIVE</option>
    <option value="BEING HELD">BEING HELD</option>
  </select>

  <label><input type="checkbox" id="autoRefresh"> Auto‚Äërefresh every 60‚ÄØs</label>
</div>

<p id="status">Status: Waiting‚Ä¶</p>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
  const pointAPI = "https://delivery.maps.gov.bc.ca/arcgis/rest/services/whse/bcgw_pub_whse_land_and_natural_resource/MapServer/20";
  let hasStatusField = false;
  let map, layerGroup, userMarker;
  let refreshTimer, userLat, userLon;

  initMap();
  checkLayerMetadata();

  function initMap(lat=53.7, lon=-127.6) {
    map = L.map('map').setView([lat, lon], 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OSM' }).addTo(map);
    layerGroup = L.layerGroup().addTo(map);
  }

  function checkLayerMetadata() {
    fetch(pointAPI + "?f=json")
      .then(res => res.json())
      .then(meta => {
        console.log("Layer metadata:", meta);
        if (meta.fields && meta.fields.some(f => f.name === "FIRE_STATUS")) {
          hasStatusField = true;
          console.log("FIRE_STATUS is available.");
        } else {
          console.warn("FIRE_STATUS is not present in this layer.");
        }
      })
      .catch(err => console.error("Metadata fetch failed:", err));
  }

  function getLocation() {
    navigator.geolocation?.getCurrentPosition(p => checkLoc(p.coords.latitude, p.coords.longitude), showError);
  }

  function manualCheck() {
    const lat = parseFloat(document.getElementById('lat').value);
    const lon = parseFloat(document.getElementById('lon').value);
    if (!isNaN(lat) && !isNaN(lon)) checkLoc(lat, lon);
    else alert("Enter valid coordinates.");
  }

  function checkLoc(lat, lon) {
    userLat = lat; userLon = lon;
    map.setView([lat, lon], 10);
    layerGroup.clearLayers();
    if (userMarker) map.removeLayer(userMarker);
    userMarker = L.marker([lat, lon]).addTo(layerGroup).bindPopup("üìç You").openPopup();
    document.getElementById("status").innerText = "Querying fires‚Ä¶";
    queryFires();
    if (document.getElementById("autoRefresh").checked) {
      clearInterval(refreshTimer);
      refreshTimer = setInterval(() => queryFires(), 60000);
    } else clearInterval(refreshTimer);
  }

  function queryFires() {
    const statusVal = document.getElementById("statusFilter").value;
    const where = hasStatusField && statusVal ? `FIRE_STATUS='${statusVal}'` : "1=1";
    const params = new URLSearchParams({
      where,
      geometry: `${userLon},${userLat}`,
      geometryType: "esriGeometryPoint",
      spatialRel: "esriSpatialRelIntersects",
      distance: 10000,
      inSR: "4326",
      outFields: "*",
      f: "json"
    });

    fetch(pointAPI + "/query?" + params)
      .then(res => res.json())
      .then(resp => {
        console.log("Query response:", resp);
        if (resp.error) {
          document.getElementById("status").innerText = "API error: " + resp.error.message;
          return;
        }
        const feats = resp.features || [];
        if (!feats.length) {
          document.getElementById("status").innerText = "‚úÖ No fires found.";
          return;
        }
        document.getElementById("status").innerText = `‚ö†Ô∏è ${feats.length} fire(s) matched.`;
        feats.forEach(f => {
          if (!f.geometry?.x) return;
          const lat = f.geometry.y, lon = f.geometry.x;
          const props = f.attributes || {};
          const popup = `
            üî• ID: ${props.FIRE_NUMBER||props.FIRE_ID||'N/A'}<br>
            Status: ${props.FIRE_STATUS||'Unknown'}<br>
            Distance: ${getDist(lat, lon).toFixed(1)}‚ÄØkm
          `;
          L.marker([lat, lon], {
            icon: L.icon({ iconUrl: "https://cdn-icons-png.flaticon.com/512/482/482523.png", iconSize: [25,25] })
          }).addTo(layerGroup).bindPopup(popup);
        });
      })
      .catch(err => {
        console.error("API/network error:", err);
        document.getElementById("status").innerText = "Network/API request failed.";
      });
  }

  function getDist(lat2, lon2) {
    const toRad = x => x * Math.PI / 180;
    const R = 6371;
    const dLat = toRad(lat2 - userLat), dLon = toRad(lon2 - userLon);
    const a = Math.sin(dLat/2)**2 + Math.cos(toRad(userLat))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  }

  function showError(e) {
    const msg = {1:"Permission denied",2:"Position unavailable",3:"Timeout"}[e.code] || "Unknown";
    document.getElementById("status").innerText = `Geolocation error: ${msg}`;
  }
</script>

</body>
</html>
